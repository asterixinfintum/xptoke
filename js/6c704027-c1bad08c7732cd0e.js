"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7119],{35486:function(e,t,n){let a;n.d(t,{Y:function(){return ek},a:function(){return eg},a1:function(){return eL},a2:function(){return ex},b:function(){return q},bB:function(){return eZ},bE:function(){return ew},bI:function(){return eU},bK:function(){return eo},bL:function(){return ec},bP:function(){return eN},bR:function(){return eO},bj:function(){return eE},bk:function(){return G},bl:function(){return eM},bz:function(){return ej},c:function(){return R},d:function(){return D},e:function(){return _},f:function(){return Q},g:function(){return B},h:function(){return F},k:function(){return eC},l:function(){return j},o:function(){return em},q:function(){return ep},s:function(){return ev},u:function(){return $},v:function(){return ey},y:function(){return T}}),n(33957);var i=n(2265),r=n(64095),o=n(8186),c=n(66962),l=n(31346),s=n(45094),u=n(57437),d=n(11814),h=n(16550),g=n(13165),f=n(87764),w=n(47604),m=n(79699),p=n(45284),v=n(46567),y=n(83531),C=n(98372),b=n(38),I=n(77806);n(97252);let P=(0,i.createContext)(void 0),A=(0,i.createContext)(void 0);function T(){return(0,i.useContext)(A)}let S=e=>{let t=e?.getOptions();return t&&"walletConnectReceiver"in t&&t.walletConnectReceiver},W="lastConnectedWallet",k=new Map,L=new Map,x=(0,i.createContext)(void 0);function E(e,t){let{chains:n,chainToConnect:r,dAppMeta:o,clientId:c,activeChain:l}=e,[s,u]=(0,i.useState)(void 0),[d,h]=(0,i.useState)(t.connectionStatus),[g,f]=(0,i.useState)(),[m,p]=(0,i.useState)(),[v,y]=(0,i.useState)(),[C,b]=(0,i.useState)(void 0),[I,P]=(0,i.useState)(void 0),A=(0,i.useMemo)(()=>({chains:n,dappMetadata:o,chain:l||n[0],clientId:c}),[n,o,l,c]),T=(0,i.useCallback)(e=>{let t=e.create(A);return t.walletId===w.w.magicLink&&p(t),k.set(t,e),t},[A]),S=(0,i.useCallback)(async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=k.get(e);if(!a)throw Error("Wallet config not found for given wallet instance. Do not create a wallet instance manually - use the useCreateWalletInstance() hook instead");let[i,r,o]=await Promise.all([e.getSigner(),e.getChainId(),e.getAddress()]);f(e),b(r),P(o),u(i),y(a),h("connected");let c=e.getPersonalWallet();if(L.set(c,e),n)return;let l={walletId:a.id,connectParams:t||e.getConnectParams()},s=k.get(c);c&&s&&(l.connectParams={...l.connectParams,personalWallet:{walletId:s.id,connectParams:c.getConnectParams()}}),U(l)},[]),x=(0,i.useCallback)(async e=>{let t=await a.getItem(W);if(t)try{let n=JSON.parse(t);n.connectParams?n.connectParams.chainId=e:n.connectParams={chainId:e},await a.setItem(W,JSON.stringify(n))}catch(e){console.error(`Error saving the last active chain: ${e}`)}},[]),E=(0,i.useCallback)(async e=>{if(!g)throw Error("No active wallet");await g.switchChain(e);let t=await g.getSigner();await x(e),u(t)},[g,x]),M=(0,i.useCallback)(async function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let[a,i]=t,o={chainId:r?.chainId,...i||{}},c=T(a);h("connecting");try{a.id===w.w.magicLink&&U({walletId:a.id,connectParams:o}),await c.connect(o),S(c,o)}catch(e){throw console.error(`Error connecting to wallet: ${e}`),h("disconnected"),e}return c},[T,S,r]),j=(0,i.useCallback)(()=>{h("disconnected"),u(void 0),f(void 0),y(void 0),b(void 0),P(void 0),a.removeItem(W)},[]),Z=(0,i.useCallback)(async()=>{if(!g){j();return}j();let e=g.getPersonalWallet();await g.disconnect(),e&&await e?.disconnect()},[g,j]);return(0,i.useEffect)(()=>{if(!g){u(void 0),b(void 0),P(void 0);return}let e=async()=>{Promise.all([g.getSigner(),g.getChainId(),g.getAddress()]).then(e=>{let[t,n,a]=e;u(t),b(n),P(a)})};return e(),g.addListener("change",e),g.addListener("disconnect",j),()=>{g.removeListener("change",e),g.removeListener("disconnect",j)}},[g,j]),(0,i.useEffect)(()=>{g&&g.updateChains(n)},[g,n]),{signer:s,connectionStatus:d,setConnectionStatus:h,activeWallet:g,createdWalletInstance:m,activeWalletConfig:v,createWalletInstance:T,setConnectedWallet:S,switchChain:E,connectWallet:M,disconnectWallet:Z,chainId:C,address:I}}function M(e){let t=e.autoSwitch?e.activeChain:void 0,n=e.autoConnectTimeout||15e3,r={chains:e.chains,dAppMeta:e.dAppMeta,activeChain:e.activeChain,clientId:e.clientId,chainToConnect:t},{signer:o,connectionStatus:c,setConnectionStatus:l,activeWallet:s,createdWalletInstance:d,activeWalletConfig:h,createWalletInstance:g,setConnectedWallet:f,switchChain:p,connectWallet:v,disconnectWallet:y,address:C,chainId:b}=E(r,{connectionStatus:"unknown"}),I=E(r,{connectionStatus:"disconnected"}),[P,A]=(0,i.useState)(!1),[T,M]=(0,i.useState)();a||(a=e.createWalletStorage("coordinatorStorage")),(0,i.useEffect)(()=>{if(!s)return;let e=async()=>{let e=s?.getOptions(),t=new m.Wj({walletConnectReceiver:{...e?.walletConnectReceiver===!0?{}:e?.walletConnectReceiver}},s);await t.init(),M(t)};S(s)&&e()},[s]);let j=(0,i.useRef)(!1);(0,i.useEffect)(()=>{if(!j.current&&(j.current=!0,!e.signerWallet&&!s&&"unknown"===c)){if(!1===e.shouldAutoConnect){l("disconnected");return}!async function(){let t;let i=await Z();if(!i){l("disconnected");return}let r=e.supportedWallets.find(e=>e.id===i.walletId);if(!r){l("disconnected");return}let o=i.connectParams?.personalWallet,c=!1;r.personalWallets&&!o&&(c=i.walletId!==w.w.magicLink||!i.connectParams||!("oauthProvider"in i.connectParams),o={walletId:i.walletId,connectParams:i.connectParams});let s=o;if(s){let e=(r.personalWallets||[]).find(e=>e.id===s.walletId);if(e){t=g(e);try{await O(t.autoConnect(s.connectParams),{ms:n,message:N}),c&&f(t,s.connectParams,!0)}catch(e){console.error("Failed to auto connect personal wallet"),console.error(e),l("disconnected");return}i.connectParams={...i.connectParams,personalWallet:t}}else{l("disconnected");return}}let u=g(r);try{A(!0),l("connecting"),t&&L.set(t,u),await O(u.autoConnect(i.connectParams),{ms:n,message:N}),c||f(u,i.connectParams,!0)}catch(e){console.error("Failed to auto connect wallet"),console.error(e),e instanceof Error&&e.message===N&&a.removeItem(W),l("disconnected")}A(!1)}()}},[g,e.supportedWallets,f,e.shouldAutoConnect,s,c,e.signerWallet,l,n]);let U=(0,i.useRef)();return(0,i.useEffect)(()=>{if(!e.signerWallet){U.current&&(y(),U.current=void 0);return}U.current!==e.signerWallet&&(f(g(e.signerWallet)),U.current=e.signerWallet)},[g,e.supportedWallets,f,e.signerWallet,y]),(0,u.jsx)(x.Provider,{value:{address:C,chainId:b,disconnect:y,wallets:e.supportedWallets,connect:v,signer:o,activeWallet:s,activeWalletConfig:h,connectionStatus:c,setConnectionStatus:l,createWalletInstance:g,createdWalletInstance:d,createWalletStorage:e.createWalletStorage,switchChain:p,setConnectedWallet:f,activeChain:e.activeChain,chainToConnect:t,getWalletConfig:e=>k.get(e),getWrapperWallet:e=>L.get(e),activeChainSetExplicitly:e.activeChainSetExplicitly,clientId:e.clientId,walletConnectHandler:T,personalWalletConnection:I,isAutoConnecting:P},children:e.children})}function j(){let e=(0,i.useContext)(x);if(!e)throw Error("useWalletContext() can only be used inside <ThirdwebProvider />");return e}async function Z(){let e=await a.getItem(W);if(!e)return null;try{return JSON.parse(e)}catch{return await a.removeItem(W),null}}async function U(e){try{await a.setItem(W,JSON.stringify(e))}catch(e){console.error("Error saving the last connected wallet info",e)}}function O(e,t){return new Promise((n,a)=>{let i=setTimeout(()=>{a(Error(t.message))},t.ms);e.then(e=>{clearTimeout(i),n(e)},e=>{clearTimeout(i),a(e)})})}let N="Failed to Auto connect. Auto connect timed out. You can increase the timeout duration using the autoConnectTimeout prop on <ThirdwebProvider />";function $(e){let t=j();(0,s.Z)(t,"useWallet() hook must be used within a <ThirdwebProvider/>");let n=t.activeWallet;if(n&&(!e||n.walletId===e))return n}function F(){let e=j();return(0,s.Z)(e,"useWallet() hook must be used within a <ThirdwebProvider/>"),e.activeWalletConfig}function B(){let e=j();return(0,s.Z)(e,"useWallets() hook must be used within a <ThirdwebProvider/>"),e.wallets}function q(){let e=j();return(0,s.Z)(e,"useConnect() hook must be used within a <ThirdwebProvider/>"),e.connect}function _(){let e=j();return(0,s.Z)(e,"useDisconnect() hook must be used within a <ThirdwebProvider/>"),e.disconnect}function R(){let e=j();return(0,s.Z)(e,"useConnectionStatus() must be used within a <ThirdwebProvider/>"),e.connectionStatus}function D(){let e=j();return(0,s.Z)(e,"useCreateWalletInstance() must be used within a <ThirdwebProvider/>"),e.createWalletInstance}function Q(){let e=j();return(0,s.Z)(e,"useSwitchChain() must be used within a <ThirdwebProvider/>"),e.switchChain}let K="auth_token_storage_key",V="tw-cache";function J(e){return[V,...e.filter(e=>"string"!=typeof e||e!==V)]}function Y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:y.d,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return J(["contract",e,...t])}function z(e,t){return J(H.network.active(t).concat(e))}let H={auth:{user:()=>J(["user"])},network:{active:e=>J(["chainId",e])},wallet:{balance:(e,t,n)=>J(z(J(["balance",{walletAddress:t,tokenAddress:n}]),e))},contract:{read:(e,t)=>Y(e,["read",t]),type:e=>Y(e,["contract-type"]),compilerMetadata:e=>Y(e,["publish-metadata"]),typeAndCompilerMetadata:e=>Y(e,["contract-type-and-metadata"]),metadata:e=>Y(e,["metadata"]),extractFunctions:e=>Y(e,["extractFunctions"]),call:(e,t,n,a)=>Y(e,["call",t,n,a]),accountFactory:{getAll:e=>Y(e,["accountFactory"]),isAccountDeployed:(e,t)=>Y(e,["isAccountDeployed",t]),getAllForAddress:(e,t)=>Y(e,["getAllForAddress",t])},account:{signers:e=>Y(e,["account","signers"])},app:{get:e=>Y(e,["appURI"])},events:{getEvents:(e,t)=>Y(e,["events","getEvents",{eventName:t}]),getAllEvents:e=>Y(e,["events","getAllEvents"])},nft:{get:(e,t)=>Y(e,["get",{tokenId:t}]),balanceOf:(e,t,n)=>Y(e,["balanceOf",{owner:t,tokenId:n}]),query:{all:(e,t)=>Y(e,t?["query","all",t]:["query","all"]),totalCirculatingSupply:(e,t)=>Y(e,["query","totalCirculatingSupply",t??"0"]),totalCount:e=>Y(e,["query","totalCount"]),owned:{all:(e,t)=>Y(e,["query","owned","all",t])}},sharedMetadata:{get:e=>Y(e)},drop:{getAllUnclaimed:(e,t)=>Y(e,t?["getAllUnclaimed",t]:["getAllUnclaimed"]),getAllClaimed:(e,t)=>Y(e,t?["getAllClaimed",t]:["getAllClaimed"]),totalUnclaimedSupply:e=>Y(e,["totalUnclaimedSupply"]),totalClaimedSupply:e=>Y(e,["totalClaimedSupply"]),revealer:{getBatchesToReveal:(e,t)=>Y(e,t?["getBatchesToReveal",t]:["getBatchesToReveal"])}}},token:{totalSupply:e=>Y(e,["totalSupply"]),decimals:e=>Y(e,["decimals"]),balanceOf:(e,t)=>Y(e,["balanceOf",{walletAddress:t}])},marketplace:{getListing:(e,t)=>Y(e,["getListing",{listingId:t}]),getAllListings:(e,t)=>Y(e,t?["getAllListings",t]:["getAllListings"]),getTotalCount:e=>Y(e,["getTotalCount"]),getActiveListings:(e,t)=>Y(e,t?["getActiveListings",t]:["getActiveListings"]),auction:{getBidBufferBps:(e,t)=>Y(e,["auction","getBidBufferBps",{listingId:t}]),getWinningBid:(e,t)=>Y(e,["auction","getWinningBid",{listingId:t}]),getMinimumNextBid:(e,t)=>Y(e,["auction","getMinimumNextBid",{listingId:t}]),getWinner:(e,t)=>Y(e,["auction","getWinner",{listingId:t}])},directListings:{getAll:(e,t)=>Y(e,t?["directListings","getAll",t]:["directListings","getAll"]),getAllValid:(e,t)=>Y(e,t?["directListings","getAllValid",t]:["directListings","getAllValid"]),getListing:(e,t)=>Y(e,["directListings","getListing",{listingId:t}]),getTotalCount:e=>Y(e,["directListings","getTotalCount"])},englishAuctions:{getAll:(e,t)=>Y(e,t?["englishAuctions","getAll",t]:["englishAuctions","getAll"]),getAllValid:(e,t)=>Y(e,t?["englishAuctions","getAllValid",t]:["englishAuctions","getAllValid"]),getAuction:(e,t)=>Y(e,["englishAuctions","getAuction",{auctionId:t}]),getWinningBid:(e,t)=>Y(e,["englishAuctions","getWinningBid",{auctionId:t}]),getTotalCount:e=>Y(e,["englishAuctions","getTotalCount"])}}}};function G(){let e=(0,r.NL)(),t=T(),n=(0,o.D)({mutationFn:async()=>{(0,s.Z)(t,"Please specify an authConfig in the ThirdwebProvider"),(0,s.Z)(t.authUrl,"Please specify an authUrl in the authConfig."),await fetch(`${t.authUrl}/logout`,{method:"POST",credentials:"include"}),t.secureStorage?.removeItem(K),e.invalidateQueries(H.auth.user())}});return{logout:n.mutateAsync,isLoading:n.isLoading}}let X=e=>{let{value:t,children:n}=e,a=(0,i.useMemo)(()=>{if(t)return{...t,authUrl:t.authUrl?.replace(/\/$/,"")}},[t]);return(0,u.jsxs)(A.Provider,{value:a,children:[n,(0,u.jsx)(ee,{})]})};function ee(){let e=$(),{logout:t}=G(),{switchAccount:n}=function(){let e=(0,r.NL)(),t=T(),n=(0,o.D)({mutationFn:async n=>{(0,s.Z)(t,"Please specify an authConfig in the ThirdwebProvider"),(0,s.Z)(t.authUrl,"Please specify an authUrl in the authConfig."),await fetch(`${t.authUrl}/switch-account`,{method:"POST",credentials:"include",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:n})}),e.invalidateQueries(H.auth.user())}});return{switchAccount:n.mutateAsync,isLoading:n.isLoading}}(),a=T(),c=(0,r.NL)();return(0,i.useEffect)(()=>{let i=async e=>{if(e.address)try{await n(e.address)}catch(t){console.debug(`[Auth] Failed to switch account to ${e.address} with error:
`,t)}},r=async()=>{try{await t()}catch(e){console.debug(`[Auth] Failed to logout with error:
`,e)}},o=!!e&&a&&a.authUrl;return o&&(e.addListener("connect",i),e.addListener("change",i),e.addListener("disconnect",r)),()=>{o&&(e.removeListener("connect",i),e.removeListener("change",i),e.removeListener("disconnect",r))}},[e,c,a,t,n]),null}function et(e,t,n){return[(0,i.useMemo)(()=>e.map(e=>(0,d.nRj)(e,n)),[e,n]),(0,i.useMemo)(()=>t&&"string"!=typeof t&&"number"!=typeof t?(0,d.nRj)(t,n):t,[t,n])]}let en=e=>{let{queryClient:t,children:n}=e,a=(0,i.useMemo)(()=>t||new c.S,[t]);return(0,u.jsx)(r.aH,{client:a,children:n})},ea=(0,i.createContext)(void 0),ei=e=>{let{value:t,children:n}=e;return(0,u.jsx)(ea.Provider,{value:t,children:n})},er=(0,i.createContext)({});function eo(){let{sdk:e}=function(){let e=(0,i.useContext)(er);return(0,s.Z)(e._inProvider,"useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?"),e}();return e}function ec(){let e=eo();return e?._chainId}let el={wallet:void 0,address:void 0,chainId:void 0,signer:void 0},es=(0,i.createContext)(void 0),eu=e=>{let{signer:t,children:n}=e,{chains:a,clientId:r}=function(){let e=(0,i.useContext)(ea);return(0,s.Z)(e,"useThirdwebConfigContext() hook must be used within a <ThirdwebProvider/>"),e}(),o=eo()?.storage,[c,l]=(0,i.useState)({...el,signer:t||void 0});return(0,i.useEffect)(()=>{l(e=>({...e,signer:t||void 0}))},[t]),(0,i.useEffect)(()=>{if(!o)return;let e=t;return t?Promise.all([t.getAddress(),t.getChainId()]).then(n=>{let i,[c,s]=n,u=a.find(e=>e.chainId===s);if(u)try{i=(0,d.OZ$)(u,r)[0]}catch(e){console.error(e)}t===e&&l({wallet:new g.U(t,{readonlySettings:i?{rpcUrl:i,chainId:s}:void 0},o),address:c,chainId:s,signer:t})}).catch(e=>{}):l(el),()=>{e=void 0}},[t,r]),(0,u.jsx)(es.Provider,{value:c,children:n})},ed=e=>{let{sdkOptions:t={},storageInterface:n,supportedChains:a,activeChain:r,signer:o,children:c,clientId:l,secretKey:s}=e,g=(0,i.useMemo)(()=>r?"number"==typeof r?r:"string"==typeof r?a.find(e=>e.slug===r)?.chainId:r.chainId:a[0]?.chainId,[r,a]),f=(0,i.useMemo)(()=>{let e,i,r=g,o=a.find(e=>e.chainId===r);if(o||void 0===r||(console.warn(`The chainId ${r} is not in the configured chains, please add it to the ThirdwebProvider`),r=void 0),o&&o.rpc.length>0)try{let t=(0,d.OZ$)(o,l)[0];e={chainId:o.chainId,rpcUrl:t}}catch(e){}let c={readonlySettings:e,...t,supportedChains:a};if(r&&(i=new h.x9T(r,{...c,clientId:l,secretKey:s},n)),!i){if(a.length>0)r=a[0].chainId,i=new h.x9T(r,c,n);else{console.error("No chains configured, please pass a chain or chains to the ThirdwebProvider");return}}return i._chainId=r,i},[g,a,t,n,l,s]);(0,i.useEffect)(()=>{f&&f._chainId===g&&(o?f.updateSignerOrProvider(o):g&&f.updateSignerOrProvider(g))},[f,f?._chainId,o,g]);let w=(0,i.useMemo)(()=>({sdk:f&&f._chainId===g?f:void 0,_inProvider:!0}),[g,f]);return(0,u.jsx)(er.Provider,{value:w,children:c})},eh=e=>{let{signer:t,children:n,queryClient:a,supportedChains:r,activeChain:o,clientId:c,...l}=e;c||(0,g.c)("No API key. Please provide a clientId. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key",c,void 0);let s=r||d.gL9,h=(0,i.useMemo)(()=>"object"==typeof o&&null!==o?s.find(e=>e.chainId===o.chainId)?s.map(e=>e.chainId===o.chainId?o:e):[...s,o]:s,[s,o]),[f,w]=et(h,o||h[0],c),m=(0,i.useMemo)(()=>w&&"string"!=typeof w&&"number"!=typeof w?[...f.filter(e=>e.chainId!==w.chainId),w].filter((e,t,n)=>t===n.findIndex(t=>t.chainId===e.chainId)):f,[f,w]);return(0,u.jsx)(ei,{value:{chains:m,clientId:c},children:(0,u.jsx)(en,{queryClient:a,children:(0,u.jsx)(ed,{signer:t,supportedChains:m,clientId:c,activeChain:w,...l,children:(0,u.jsx)(eu,{signer:t,children:n})})})})},eg=e=>{let{activeChain:t,createWalletStorage:n=p.c}=e,a=e.supportedChains||d.gL9,r=(0,i.useMemo)(()=>"object"==typeof t&&null!==t?a.find(e=>e.chainId===t.chainId)?a.map(e=>e.chainId===t.chainId?t:e):[...a,t]:a,[a,t]),[o,c]=et(r,e.activeChain||r[0],e.clientId),l=(0,i.useMemo)(()=>{if("number"==typeof c){let e=o.find(e=>e.chainId===c);if(!e)throw Error(`Invalid chainId: ${c}. It is not one of supportedChains`);return e}if("string"==typeof c){let e=o.find(e=>e.slug===c);if(!e)throw Error(`Invalid chain: "${c}". It is not one of supportedChains`);return e}return c},[c,o]),s=e.dAppMeta;return(0,u.jsx)(P.Provider,{value:e.theme,children:(0,u.jsx)(M,{chains:o,supportedWallets:e.supportedWallets,shouldAutoConnect:e.autoConnect,createWalletStorage:n,dAppMeta:s,activeChain:l,autoSwitch:e.autoSwitch,autoConnectTimeout:e.autoConnectTimeout,clientId:e.clientId,activeChainSetExplicitly:!!e.activeChain,signerWallet:e.signerWallet,children:(0,u.jsx)(ef,{queryClient:e.queryClient,sdkOptions:e.sdkOptions,supportedChains:o,activeChain:l,storageInterface:e.storageInterface,authConfig:e.authConfig,clientId:e.clientId,secretKey:e.secretKey,children:(0,u.jsx)(X,{value:e.authConfig,children:e.children})})})})},ef=e=>{let{children:t,...n}=e,a=j()?.signer;return(0,u.jsx)(eh,{signer:a,...n,children:t})};function ew(){let e=(0,i.useContext)(ea);return(0,s.Z)(e,"useSupportedChains() hook must be used within a <ThirdwebProvider/>"),e.chains}function em(e){let t=ep(),{wallet:n,address:a,chainId:r}=function(){let e=(0,i.useContext)(es);return(0,s.Z)(e,"useThirdwebConnectedWalletContext() hook must be used within a <ThirdwebProvider/>"),e}(),o=(0,i.useMemo)(()=>H.wallet.balance(r||-1,a,e),[r,e,a]);return(0,l.a)(o,()=>n?.balance(e),{enabled:!!n&&!!t&&!!r,retry:!0,keepPreviousData:!1})}function ep(){let e=(0,i.useContext)(es),t=(0,i.useContext)(x);return t?t.address:((0,s.Z)(e,"useAddress() hook must be used within a <ThirdwebProvider/>"),e.address)}function ev(){let e=(0,i.useContext)(es),t=(0,i.useContext)(x);return t?t.chainId:((0,s.Z)(e,"useChainId() hook must be used within a <ThirdwebProvider/> or <ThirdwebSDKProvider/> component"),e.chainId)}function ey(){let e=ev(),t=ew(),n=(0,i.useMemo)(()=>t.find(t=>t.chainId===e),[e,t]),a=(0,i.useMemo)(()=>{if(!n)return d.gL9.find(t=>t.chainId===e)},[e,n]);return n||a}function eC(){let e=ey(),t=ev(),n=Q(),a=ew(),r=$(),o=!!(0,v.a)(globalThis.window)&&globalThis.window.ethereum.isMetaMask,c=!!(0,v.a)(globalThis.window)&&globalThis.window.ethereum.isCoinbaseWallet,l=!r||r.walletId===w.w.walletConnectV1||r.walletId===w.w.walletConnect||r.walletId===w.w.metamask&&!o||r.walletId===w.w.coinbase&&!c,[s,u]=(0,i.useState)(void 0),[h,g]=(0,i.useState)(!1),f=(0,i.useCallback)(async e=>{g(!0),u(void 0);try{await n(e)}catch(e){return u(e),g(!1),{data:void 0,error:e}}return g(!1),{data:a.find(t=>t.chainId===e)||d.gL9.find(t=>t.chainId===e),error:void 0}},[n,a]);return[{data:{chain:void 0===t?void 0:e||{chainId:t,unsupported:!0},chains:r?a:[]},error:s,loading:h},l?void 0:f]}let eb={persist:!1};function eI(e,t){(0,s.Z)(null!==e||void 0!==e,t)}function eP(e,t,n){let a=ec(),i={...n,enabled:!!(a&&n?.enabled)};return(0,l.a)(z(e,a),t,i)}async function eA(e,t){if(!e||!t)return null;try{return await t.resolveContractType(e)}catch(e){return console.error("failed to resolve contract type",e),"custom"}}let eT={cacheKey:(e,t)=>z(H.contract.type(e),t),useQuery:function(e){let t=eo();return eP(H.contract.type(e),()=>eA(e,t),{cacheTime:1/0,staleTime:1/0,enabled:!!e&&!!t})},fetchQuery:eA};function eS(e,t){if(!e||!t)return null;try{return t.getPublisher().fetchCompilerMetadataFromAddress(e)}catch(e){return null}}let eW={cacheKey:(e,t)=>z(H.contract.compilerMetadata(e),t),useQuery:function(e){let t=eo();return eP(H.contract.compilerMetadata(e),()=>eS(e,t),{cacheTime:1/0,staleTime:1/0,enabled:!!e&&!!t})},fetchQuery:eS};function ek(e,t){let n=eo(),a=(0,r.NL)(),i=ec(),o=eP(["contract-instance",e,{wallet:ep(),walletChainId:ev(),sdkTimestamp:n?._constructedAt,contractTypeOrABI:t},eb],async()=>{if(eI(e,"contract address is required"),(0,s.Z)(n,"SDK not initialized"),(0,s.Z)(i,"active chain id is required"),!t||"custom"===t){let t;let r=(0,f.g)(e);if(r)return n.getContract(e,r);let o=await a.fetchQuery(eT.cacheKey(e,i),()=>eT.fetchQuery(e,n),{cacheTime:1/0,staleTime:1/0});return"custom"===o&&(t=(await a.fetchQuery(eW.cacheKey(e,i),()=>eW.fetchQuery(e,n),{cacheTime:1/0,staleTime:1/0,retry:0}))?.abi),(0,s.Z)(o,"failed to resolve contract type"),n.getContract(e,t||o)}return n.getContract(e,t)},{keepPreviousData:!0,cacheTime:1/0,staleTime:1/0,enabled:!!e&&!!n&&!!i,retry:0});return{...o,data:o.data,contract:o.data}}function eL(e,t,n,a){let i=e?.getAddress();return eP(H.contract.call(i,t,n,a),()=>(eI(e,"contract must be defined"),eI(t,"function name must be provided"),e.call(t,n,a)),{enabled:!!e&&!!t})}function ex(e,t){let n=ec(),a=e?.getAddress(),i=(0,r.NL)();return(0,o.D)(async n=>{let{args:a,overrides:i}=n;return eI(e,"contract must be defined"),eI(t,"function name must be provided"),e.call(t,a,i)},{onSettled:()=>i.invalidateQueries(z(Y(a),n))})}function eE(){let e=(0,r.NL)(),t=T(),n=$(),a=(0,o.D)({mutationFn:async()=>{let a;(0,s.Z)(t,"Please specify an authConfig in the ThirdwebProvider"),(0,s.Z)(n,"You need a connected wallet to login."),(0,s.Z)(t.authUrl,"Please specify an authUrl in the authConfig.");let i=await n.getAddress(),r=await n.getChainId(),o=await fetch(`${t.authUrl}/payload`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:i,chainId:r.toString()})});if(!o.ok)throw Error(`Failed to get payload with status code ${o.status}`);try{({payload:a}=await o.json())}catch{throw Error("Failed to get payload")}let c=await (0,I.s)({wallet:n,payload:a});if(!(o=await fetch(`${t.authUrl}/login`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({payload:c}),credentials:"include"})).ok){let e=await o.json();if(e.error)throw Error(e.error);throw Error(`Login request failed with status code ${o.status}`)}let{token:l}=await o.json();return await t.secureStorage?.setItem(K,l),e.invalidateQueries(H.auth.user()),l}});return{login:()=>a.mutateAsync(),isLoading:a.isLoading}}function eM(){let e=T(),{data:t,isLoading:n}=(0,l.a)(H.auth.user(),async()=>{(0,s.Z)(e,"Please specify an authConfig in the ThirdwebProvider"),(0,s.Z)(e.authUrl,"Please specify an authUrl in the authConfig.");let t=await e.secureStorage?.getItem(K),n={credentials:"include",...t?{headers:{Authorization:`Bearer ${t}`}}:{}},a=await fetch(`${e.authUrl}/user`,n);return await a.json()},{enabled:!!e});return{user:t,isLoggedIn:!!t,isLoading:n}}function ej(){let e=eo();return e?.storage}function eZ(){let e=ev(),t=ec();return!!t&&-1!==t&&!!e&&t!==e}function eU(){let e=ep(),t=ew(),{clientId:n}=j(),a=t.find(e=>1===e.chainId);return(0,l.a)({queryKey:["ens",e,a?.rpc],cacheTime:864e5,staleTime:36e5,retry:!1,enabled:!!e,queryFn:async()=>{if(!e)return null;let t=(0,h.rV4)(1,{clientId:n,supportedChains:a?[{chainId:1,rpc:[...a.rpc],nativeCurrency:a.nativeCurrency,slug:a.slug}]:void 0});if(t instanceof C.r){let[n,a]=await Promise.all([t.lookupAddress(e),t.getAvatar(e)]);return{ens:n,avatarUrl:a}}return{ens:await t.lookupAddress(e),avatarUrl:null}}})}function eO(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return`${e.substring(0,t?4:6)}...${e.substring(e.length-(t?3:4))}`}function eN(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];if(!e)return"";try{let n=b.getAddress(e);return eO(n,t)}catch{return e}}}}]);